
export interface Room {
  id: string;
  participants: any[];
  history: GameSnapshot[];
  participantPlayerMap: Record<string, string>;
}

export enum PlayerState {
  ready = "ready",
  working = "working",
};

export enum GameState {
  not_started = "not_started",
  in_progress = "in_progress",
  completed = "completed",
};

export interface Player {
  id: string;
  state: PlayerState;
  originalProjectUrl: string;

  // kind of a hack, used to blow away prior
  // player state if a user joins another game
  roomId: string;

  displayName: string;
}

// this is generated by the client *potentially* before the server has given this user an ID
export type ClientPlayer = Partial<Player> & Pick<Player, 'originalProjectUrl'>;

export type ProjectInfo = {
  url: string;
  turns: number;
  ownerId: string;
}

export interface GameSnapshot {
  state: GameState;
  round: number;

  // simple map so that when a user indicates done
  // we can trivially know which player to send the
  // next url to.
  playerRecipientMap: Record<string, string>;
  players: Record<string, Player>;
  projects: Record<string, ProjectInfo>;
  projectAssignments: Record<string, string>;
}

export function initialGameState(): GameSnapshot {
  return {
    state: GameState.not_started,
    round: 0,
    players: {},
    playerRecipientMap: {},
    projects: {},
    projectAssignments: {},
  };
}

